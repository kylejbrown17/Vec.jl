!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AABB	./src/geom/solids.jl	/^function AABB(bot_left::VecE2, top_right::VecE2)$/;"	f
AABB	./src/geom/solids.jl	/^struct AABB$/;"	f
AbstractCoordinate	./src/coordinate_transforms.jl	/^abstract type AbstractCoordinate end$/;"	f
AbstractVec	./src/Vec.jl	/^abstract type AbstractVec{N} <: FieldVector{N, Float64} end$/;"	f
Base.:%	./src/vecSE2.jl	/^Base.:%(a::VecSE2, b::Real) = VecSE2(a.x%b, a.y%b, a.θ)$/;"	f
Base.:*	./src/vecSE2.jl	/^Base.:*(a::VecSE2, b::Real) = VecSE2(a.x*b, a.y*b, a.θ)$/;"	f
Base.:*	./src/vecSE2.jl	/^Base.:*(b::Real, a::VecSE2) = VecSE2(b*a.x, b*a.y, a.θ)$/;"	f
Base.:+	./src/coordinate_transforms.jl	/^Base.:+(a::ENU, b::ENU) = ENU(a.e+b.e, a.n+b.n, a.u+b.u)$/;"	f
Base.:+	./src/coordinate_transforms.jl	/^function Base.:+(a::UTM, b::UTM)$/;"	f
Base.:+	./src/geom/1d.jl	/^Base.:+(seg::LineSegment1D, v::Real) = LineSegment1D(seg.a + v, seg.b + v)$/;"	f
Base.:+	./src/geom/line_segments.jl	/^Base.:+(seg::LineSegment, V::VecE2) = LineSegment(seg.A + V, seg.B + V)$/;"	f
Base.:+	./src/geom/lines.jl	/^Base.:+(line::Line, V::VecE2) = Line(line.C + V, line.θ)$/;"	f
Base.:+	./src/geom/solids.jl	/^Base.:+(box::AABB, v::VecE2) = AABB(box.center + v, box.len, box.wid)$/;"	f
Base.:+	./src/geom/solids.jl	/^Base.:+(box::OBB, v::VecE2) = OBB(box.aabb+v, box.θ)$/;"	f
Base.:+	./src/geom/solids.jl	/^Base.:+(circ::Circ{VecE2}, v::VecE2) = Circ{VecE2}(circ.c + v, circ.r)$/;"	f
Base.:+	./src/vecSE2.jl	/^Base.:+(a::VecSE2, b::Real) = VecSE2(a.x+b, a.y+b, a.θ)$/;"	f
Base.:+	./src/vecSE2.jl	/^Base.:+(a::VecSE2, b::VecE2) = VecSE2(a.x+b.x, a.y+b.y, a.θ)$/;"	f
Base.:+	./src/vecSE2.jl	/^Base.:+(b::Real, a::VecSE2) = VecSE2(a.x+b, a.y+b, a.θ)$/;"	f
Base.:-	./src/coordinate_transforms.jl	/^Base.:-(a::ENU, b::ENU) = ENU(a.e-b.e, a.n-b.n, a.u-b.u)$/;"	f
Base.:-	./src/coordinate_transforms.jl	/^function Base.:-(a::UTM, b::UTM)$/;"	f
Base.:-	./src/geom/1d.jl	/^Base.:-(seg::LineSegment1D, v::Real) = LineSegment1D(seg.a - v, seg.b - v)$/;"	f
Base.:-	./src/geom/line_segments.jl	/^Base.:-(seg::LineSegment, V::VecE2) = LineSegment(seg.A - V, seg.B - V)$/;"	f
Base.:-	./src/geom/lines.jl	/^Base.:-(line::Line, V::VecE2) = Line(line.C - V, line.θ)$/;"	f
Base.:-	./src/geom/solids.jl	/^Base.:-(box::AABB, v::VecE2) = AABB(box.center - v, box.len, box.wid)$/;"	f
Base.:-	./src/geom/solids.jl	/^Base.:-(box::OBB, v::VecE2) = OBB(box.aabb-v, box.θ)$/;"	f
Base.:-	./src/geom/solids.jl	/^Base.:-(circ::Circ{VecE2}, v::VecE2) = Circ{VecE2}(circ.c - v, circ.r)$/;"	f
Base.:-	./src/vecSE2.jl	/^Base.:-(a::VecE2,  b::VecSE2) = VecE2(a.x-b.x, a.y-b.y)$/;"	f
Base.:-	./src/vecSE2.jl	/^Base.:-(a::VecSE2, b::Real) = VecSE2(a.x-b, a.y-b, a.θ)$/;"	f
Base.:-	./src/vecSE2.jl	/^Base.:-(a::VecSE2, b::VecE2) = VecSE2(a.x-b.x, a.y-b.y, a.θ)$/;"	f
Base.:-	./src/vecSE2.jl	/^Base.:-(b::Real, a::VecSE2) = VecSE2(b-a.x, b-a.y, a.θ)$/;"	f
Base.:/	./src/vecSE2.jl	/^Base.:\/(a::VecSE2, b::Real) = VecSE2(a.x\/b, a.y\/b, a.θ)$/;"	f
Base.:^	./src/vecSE2.jl	/^Base.:^(a::VecSE2, b::AbstractFloat) = VecSE2(a.x^b, a.y^b, a.θ)$/;"	f
Base.:^	./src/vecSE2.jl	/^Base.:^(a::VecSE2, b::Integer) = VecSE2(a.x^b, a.y^b, a.θ)$/;"	f
Base.atan2	./src/vecE2.jl	/^Base.atan2(a::VecE2) = atan2(a.y, a.x)$/;"	f
Base.atan2	./src/vecSE2.jl	/^Base.atan2(a::VecSE2) = atan2(a.y, a.x)$/;"	f
Base.clamp	./src/vecSE2.jl	/^Base.clamp(a::VecSE2, lo::Real, hi::Real) = VecSE2(clamp(a.x, lo, hi), clamp(a.y, lo, hi), a.θ)$/;"	f
Base.contains	./src/geom/1d.jl	/^Base.contains(P::LineSegment1D, Q::LineSegment1D) = Q.a ≥ P.a && Q.b ≤ P.b$/;"	f
Base.contains	./src/geom/1d.jl	/^Base.contains(P::LineSegment1D, v::Float64) = P.a ≤ v ≤ P.b$/;"	f
Base.contains	./src/geom/solids.jl	/^function Base.contains(box::AABB, P::VecE2)$/;"	f
Base.contains	./src/geom/solids.jl	/^function Base.contains(box::OBB, P::VecE2)$/;"	f
Base.convert	./src/coordinate_transforms.jl	/^Base.convert(::Type{ECEF}, p::VecE3) = ECEF(p.x, p.y, p.z)$/;"	f
Base.convert	./src/coordinate_transforms.jl	/^Base.convert(::Type{ENU}, p::VecE3) = ENU(p.x, p.y, p.z)$/;"	f
Base.convert	./src/coordinate_transforms.jl	/^Base.convert(::Type{LatLonAlt}, p::VecE3) = LatLonAlt(p.x, p.y, p.z)$/;"	f
Base.convert	./src/coordinate_transforms.jl	/^Base.convert(::Type{VecE3}, lla::LatLonAlt) = VecE3(lla.lat, lla.lon, lla.alt)$/;"	f
Base.convert	./src/coordinate_transforms.jl	/^Base.convert(::Type{VecE3}, p::ECEF) = VecE3(p.x, p.y, p.z)$/;"	f
Base.convert	./src/coordinate_transforms.jl	/^Base.convert(::Type{VecE3}, p::ENU) = VecE3(p.e, p.n, p.u)$/;"	f
Base.convert	./src/coordinate_transforms.jl	/^Base.convert(::Type{VecE3}, p::UTM) = VecE3(p.e, p.n, p.u)$/;"	f
Base.convert	./src/coordinate_transforms.jl	/^function Base.convert(::Type{ECEF}, enu::ENU, reference::LatLonAlt)$/;"	f
Base.convert	./src/coordinate_transforms.jl	/^function Base.convert(::Type{ECEF}, lla::LatLonAlt, datum::GeodeticDatum=WGS_84)$/;"	f
Base.convert	./src/coordinate_transforms.jl	/^function Base.convert(::Type{ENU}, ecef::ECEF, reference::LatLonAlt)$/;"	f
Base.convert	./src/coordinate_transforms.jl	/^function Base.convert(::Type{LatLonAlt}, ecef::ECEF, datum::GeodeticDatum=WGS_84)$/;"	f
Base.convert	./src/coordinate_transforms.jl	/^function Base.convert(::Type{LatLonAlt}, utm::UTM, datum::GeodeticDatum=WGS_84)$/;"	f
Base.convert	./src/coordinate_transforms.jl	/^function Base.convert(::Type{UTM}, lla::LatLonAlt, datum::GeodeticDatum=WGS_84, zone::Integer=-1)$/;"	f
Base.convert	./src/geom/line_segments.jl	/^Base.convert(::Type{LineSegment}, line::Line) = LineSegment(line.A, line.B)$/;"	f
Base.convert	./src/geom/line_segments.jl	/^Base.convert(::Type{Line}, seg::LineSegment) = Line(seg.A, seg.B)$/;"	f
Base.convert	./src/quat.jl	/^function Base.convert(::Type{Matrix{Float64}}, quat::Quat)$/;"	f
Base.convert	./src/quat.jl	/^function Base.convert(::Type{RPY}, q::Quat)$/;"	f
Base.convert	./src/vecSE2.jl	/^Base.convert(::Type{VecE2}, a::VecSE2) = VecE2(a.x, a.y)$/;"	f
Base.intersect	./src/geom/rays.jl	/^function Base.intersect(A::VecSE2, B::VecSE2)$/;"	f
Base.intersect	./src/geom/rays.jl	/^function Base.intersect(ray::Ray, seg::LineSegment)$/;"	f
Base.isfinite	./src/common.jl	/^Base.isfinite(a::AbstractVec) = all(isfinite.(a))$/;"	f
Base.isinf	./src/common.jl	/^Base.isinf(a::AbstractVec) = any(isinf.(a))$/;"	f
Base.mod2pi	./src/vecSE2.jl	/^Base.mod2pi(a::VecSE2) = VecSE2(a.x, a.y, mod2pi(a.θ))$/;"	f
Base.norm	./src/vecSE2.jl	/^Base.norm(a::VecSE2, p::Real=2) = norm(a[1:2], p)$/;"	f
Base.normalize	./src/vecSE2.jl	/^function Base.normalize(a::VecSE2, p::Real=2)$/;"	f
Base.print	./src/coordinate_transforms.jl	/^Base.print(io::IO, lla::LatLonAlt) = @printf(io, "%6.2f %7.2f %10.2f", rad2deg(lla.lat), rad2deg(lla.lon), lla.alt)$/;"	f
Base.rot180	./src/geom/lines.jl	/^Base.rot180(line::Line) = rot(line, 1π)$/;"	f
Base.rot180	./src/vecE2.jl	/^Base.rot180(a::VecE2) = VecE2(-a.x, -a.y)$/;"	f
Base.rot180	./src/vecSE2.jl	/^Base.rot180(a::VecSE2) = VecSE2(a.x, a.y, a.θ+π)$/;"	f
Base.rotl90	./src/geom/lines.jl	/^Base.rotl90(line::Line) = rot(line,  π\/2)$/;"	f
Base.rotl90	./src/vecE2.jl	/^Base.rotl90(a::VecE2) = VecE2(-a.y,  a.x)$/;"	f
Base.rotl90	./src/vecSE2.jl	/^Base.rotl90(a::VecSE2) = VecSE2(a.x, a.y, a.θ+0.5π)$/;"	f
Base.rotr90	./src/geom/lines.jl	/^Base.rotr90(line::Line) = rot(line, -π\/2)$/;"	f
Base.rotr90	./src/vecE2.jl	/^Base.rotr90(a::VecE2) = VecE2( a.y, -a.x)$/;"	f
Base.rotr90	./src/vecSE2.jl	/^Base.rotr90(a::VecSE2) = VecSE2(a.x, a.y, a.θ-0.5π)$/;"	f
Base.show	./src/quat.jl	/^Base.show(io::IO, q::Quat) = @printf(io, "QUAT({%6.3f, %6.3f, %6.3f}, %6.3f)", q.x, q.y, q.z, q.w)$/;"	f
Base.show	./src/vecE2.jl	/^Base.show(io::IO, a::VecE2) = @printf(io, "VecE2(%.3f, %.3f)", a.x, a.y)$/;"	f
Base.show	./src/vecE3.jl	/^Base.show(io::IO, a::VecE3) = @printf(io, "VecE3(%.3f, %.3f, %.3f)", a.x, a.y, a.z)$/;"	f
Base.show	./src/vecSE2.jl	/^Base.show(io::IO, a::VecSE2) = @printf(io, "VecSE2({%.3f, %.3f}, %.3f)", a.x, a.y, a.θ)$/;"	f
Base.vec	./src/Vec.jl	/^Base.vec(v::Union{AbstractVec, Quat, RPY}) = convert(Vector{Float64}, v)$/;"	f
Circ	./src/geom/solids.jl	/^Circ(x::Real, y::Real, r::Real) = Circ{VecE2}(VecE2(x, y), r)$/;"	f
Circ	./src/geom/solids.jl	/^Circ(x::Real, y::Real, z::Real, r::Real) = Circ{VecE3}(VecE3(x, y, z), r)$/;"	f
Circ	./src/geom/solids.jl	/^struct Circ{V<:AbstractVec}$/;"	f
ECEF	./src/coordinate_transforms.jl	/^struct ECEF <: AbstractCoordinate$/;"	f
ENU	./src/coordinate_transforms.jl	/^struct ENU <: AbstractCoordinate$/;"	f
GeodeticDatum	./src/coordinate_transforms.jl	/^struct GeodeticDatum$/;"	f
LatLonAlt	./src/coordinate_transforms.jl	/^struct LatLonAlt <: AbstractCoordinate$/;"	f
Line	./src/geom/lines.jl	/^Line(A::VecE2, B::VecE2) = Line((A+B)\/2, atan2(B - A))$/;"	f
Line	./src/geom/lines.jl	/^struct Line$/;"	f
LineSegment	./src/geom/line_segments.jl	/^struct LineSegment$/;"	f
LineSegment1D	./src/geom/1d.jl	/^    LineSegment1D(a::Real, b::Real) = new(convert(Float64, min(a,b)), convert(Float64, max(a,b)))$/;"	f
LineSegment1D	./src/geom/1d.jl	/^struct LineSegment1D$/;"	f
OBB	./src/geom/solids.jl	/^OBB(center::VecSE2, len::Float64, wid::Float64) = OBB(convert(VecE2, center), len, wid, center.θ)$/;"	f
OBB	./src/geom/solids.jl	/^function OBB(center::VecE2, len::Float64, wid::Float64, θ::Float64)$/;"	f
OBB	./src/geom/solids.jl	/^struct OBB$/;"	f
Projectile	./src/geom/projectiles.jl	/^struct Projectile$/;"	f
Quat	./src/quat.jl	/^struct Quat <: FieldVector{4, Float64}$/;"	f
RPY	./src/quat.jl	/^struct RPY <: FieldVector{3, Float64}$/;"	f
UTM	./src/coordinate_transforms.jl	/^struct UTM <: AbstractCoordinate$/;"	f
VecE	./src/Vec.jl	/^abstract type VecE{N} <: AbstractVec{N} end$/;"	f
VecE2	./src/vecE2.jl	/^    VecE2() = new(0.0,0.0)$/;"	f
VecE2	./src/vecE2.jl	/^    VecE2(x::Real, y::Real) = new(x,y)$/;"	f
VecE2	./src/vecE2.jl	/^struct VecE2 <: VecE{2}$/;"	f
VecE3	./src/vecE3.jl	/^    VecE3() = new(0.0,0.0,0.0)$/;"	f
VecE3	./src/vecE3.jl	/^    VecE3(x::Real, y::Real, z::Real) = new(x,y,z)$/;"	f
VecE3	./src/vecE3.jl	/^struct VecE3 <: VecE{3}$/;"	f
VecSE	./src/Vec.jl	/^abstract type VecSE{N} <: AbstractVec{N} end$/;"	f
VecSE2	./src/vecSE2.jl	/^    VecSE2(a::VecE2, θ::Real=0.0) = new(a.x, a.y, θ)$/;"	f
VecSE2	./src/vecSE2.jl	/^    VecSE2(x::Real=0.0, y::Real=0.0, θ::Real=0.0) = new(x, y, θ)$/;"	f
VecSE2	./src/vecSE2.jl	/^struct VecSE2 <: VecSE{3}$/;"	f
angledist	./src/geom/geom.jl	/^angledist( a::Real, b::Real ) = abs(deltaangle(a,b))$/;"	f
angledist	./src/geom/line_segments.jl	/^function angledist(segA::LineSegment, segB::LineSegment)$/;"	f
are_collinear	./src/geom/geom.jl	/^function are_collinear(a::AbstractVec, b::AbstractVec, c::AbstractVec, tol::Float64=1e-8)$/;"	f
body2inertial	./src/geom/geom.jl	/^function body2inertial(point::VecE2, reference::VecSE2)$/;"	f
body2inertial	./src/geom/geom.jl	/^function body2inertial(point::VecSE2, reference::VecSE2)$/;"	f
check_is_in_radians	./src/coordinate_transforms.jl	/^function check_is_in_radians(lla::LatLonAlt)$/;"	f
closest_approach_distance	./src/geom/projectiles.jl	/^function closest_approach_distance(A::Projectile, B::Projectile, t_CPA::Float64=closest_time_of_approach(A, B))$/;"	f
closest_time_of_approach	./src/geom/projectiles.jl	/^function closest_time_of_approach(A::Projectile, B::Projectile)$/;"	f
closest_time_of_approach_and_distance	./src/geom/projectiles.jl	/^function closest_time_of_approach_and_distance(A::Projectile, B::Projectile)$/;"	f
closest_time_of_approach_and_distance	./src/geom/projectiles.jl	/^function closest_time_of_approach_and_distance(P::Projectile, seg::LineSegment, if_no_col_skip_eval::Bool=false)$/;"	f
deg_min_sec_to_degrees	./src/coordinate_transforms.jl	/^deg_min_sec_to_degrees(deg::Real, min::Real, sec::Real) = convert(Float64, deg + min\/60.0 + sec\/3600.0)$/;"	f
degrees_to_deg_min_sec	./src/coordinate_transforms.jl	/^function degrees_to_deg_min_sec(degrees::Real)$/;"	f
deltaangle	./src/geom/geom.jl	/^deltaangle(a::Real, b::Real) = atan2(sin(b-a), cos(b-a))$/;"	f
dist	./src/vecE2.jl	/^dist(a::VecE2, b::VecE2) = hypot(a.x-b.x, a.y-b.y)$/;"	f
dist	./src/vecE3.jl	/^function dist(a::VecE3, b::VecE3)$/;"	f
dist2	./src/vecE2.jl	/^function dist2(a::VecE2, b::VecE2)$/;"	f
dist2	./src/vecE3.jl	/^function dist2(a::VecE3, b::VecE3)$/;"	f
eccentricity	./src/coordinate_transforms.jl	/^eccentricity(datum::GeodeticDatum) = sqrt(eccentricity_sq(datum))$/;"	f
eccentricity_sq	./src/coordinate_transforms.jl	/^eccentricity_sq(datum::GeodeticDatum) = 1.0 - datum.b^2 \/ datum.a^2$/;"	f
ensure_lon_between_pies	./src/coordinate_transforms.jl	/^function ensure_lon_between_pies(lla::LatLonAlt)$/;"	f
f	./test/test_diff.jl	/^f(x) = x+x$/;"	f
g	./test/test_diff.jl	/^g(x) = 5*x$/;"	f
get_axis	./src/quat.jl	/^function get_axis(q::Quat)$/;"	f
get_distance	./src/geom/1d.jl	/^function get_distance(seg::LineSegment1D, P::Real)::Float64$/;"	f
get_distance	./src/geom/line_segments.jl	/^function get_distance(seg::LineSegment, P::VecE2)$/;"	f
get_distance	./src/geom/lines.jl	/^function get_distance(line::Line, P::VecE2)$/;"	f
get_earth_radius	./src/coordinate_transforms.jl	/^function get_earth_radius(lat::Float64, datum::GeodeticDatum=WGS_84)$/;"	f
get_intersection_time	./src/geom/projectiles.jl	/^function get_intersection_time(A::Projectile, seg::LineSegment)$/;"	f
get_polar_angle	./src/geom/line_segments.jl	/^get_polar_angle(seg::LineSegment) = mod2pi(atan2(seg.B.y - seg.A.y, seg.B.x - seg.A.x))$/;"	f
get_polar_angle	./src/geom/lines.jl	/^get_polar_angle(line::Line) = line.θ$/;"	f
get_rotation_angle	./src/quat.jl	/^get_rotation_angle(q::Quat) = 2.0*acos(q.w)$/;"	f
get_side	./src/geom/line_segments.jl	/^get_side(seg::LineSegment, p::VecE2) = sign((seg.B.x-seg.A.x) * (p.y-seg.A.y) - (seg.B.y-seg.A.y) * (p.x-seg.A.x))$/;"	f
get_side	./src/geom/lines.jl	/^function get_side(line::Line, p::VecE2, ε::Float64=1e-10)$/;"	f
get_side	./src/geom/rays.jl	/^function get_side(ray::Ray, p::VecE2)$/;"	f
h	./test/test_diff.jl	/^h(x) = dot(x, x)$/;"	f
inertial2body	./src/geom/geom.jl	/^function inertial2body(point::VecE2, reference::VecSE2)$/;"	f
inertial2body	./src/geom/geom.jl	/^function inertial2body(point::VecSE2, reference::VecSE2)$/;"	f
inertial2body	./src/geom/solids.jl	/^function inertial2body(box::OBB, reference::VecSE2)$/;"	f
inertial2body	./src/geom/solids.jl	/^inertial2body(circ::Circ{VecE2}, reference::VecSE2) = Circ{VecE2}(inertial2body(circ.c, reference), circ.r)$/;"	f
intersects	./src/geom/1d.jl	/^intersects(P::LineSegment1D, Q::LineSegment1D) = P.b ≥ Q.a && Q.b ≥ P.a/;"	f
intersects	./src/geom/line_segments.jl	/^function intersects(segP::LineSegment, segQ::LineSegment)$/;"	f
intersects	./src/geom/rays.jl	/^function intersects(A::Ray, B::Ray)$/;"	f
intersects	./src/geom/rays.jl	/^function intersects(ray::Ray, line::Line;$/;"	f
intersects	./src/geom/rays.jl	/^function intersects(ray::Ray, seg::LineSegment)$/;"	f
invlerp	./src/Vec.jl	/^invlerp(a::Real, b::Real, c::Real) = (c - a)\/(b-a)$/;"	f
lerp	./src/Vec.jl	/^lerp(a::Real, b::Real, t::AbstractFloat) = a + (b-a)*t$/;"	f
lerp	./src/Vec.jl	/^lerp(a::Real, b::Real, t::Real) = a + (b-a)*t$/;"	f
lerp	./src/vecE2.jl	/^lerp(a::VecE2, b::VecE2, t::Real) = VecE2(a.x + (b.x-a.x)*t, a.y + (b.y-a.y)*t)$/;"	f
lerp	./src/vecE3.jl	/^lerp(a::VecE3, b::VecE3, t::Real) = VecE3(a.x + (b.x-a.x)*t, a.y + (b.y-a.y)*t, a.z + (b.z-a.z)*t)$/;"	f
lerp	./src/vecSE2.jl	/^function lerp(a::VecSE2, b::VecSE2, t::Real)$/;"	f
lerp_angle	./src/geom/geom.jl	/^lerp_angle(a::Real, b::Real, t::AbstractFloat) = a + deltaangle(a, b)*t$/;"	f
on_segment	./src/geom/line_segments.jl	/^function on_segment(P::VecE2, seg::LineSegment)$/;"	f
on_segment	./src/geom/line_segments.jl	/^on_segment(A::VecE2, P::VecE2, B::VecE2) = on_segment(P, LineSegment(A,B))$/;"	f
orientation	./src/geom/geom.jl	/^function orientation(P::VecE2, Q::VecE2, R::VecE2)$/;"	f
parallel	./src/geom/line_segments.jl	/^function parallel(segA::LineSegment, segB::LineSegment, ε::Float64=1e-10)$/;"	f
polar	./src/vecE2.jl	/^polar(r::Real, θ::Real) = VecE2(r*cos(θ), r*sin(θ))$/;"	f
polar	./src/vecSE2.jl	/^polar(r::Real, ϕ::Real, θ::Real) = VecSE2(r*cos(ϕ), r*sin(ϕ), θ)$/;"	f
proj	./src/vecE2.jl	/^function proj(a::VecE2, b::VecE2, ::Type{VecE2})$/;"	f
proj	./src/vecE2.jl	/^proj(a::VecE2, b::VecE2, ::Type{Float64}) = (a.x*b.x + a.y*b.y) \/ hypot(b.x, b.y) # dot(a,b) \/ |b|$/;"	f
proj	./src/vecE3.jl	/^function proj(a::VecE3, b::VecE3, ::Type{VecE3})$/;"	f
proj	./src/vecE3.jl	/^proj(a::VecE3, b::VecE3, ::Type{Float64}) = (a.x*b.x + a.y*b.y + a.z*b.z) \/ sqrt(b.x*b.x + b.y*b.y + b.z*b.z) # dot(a,b) \/ |b|$/;"	f
propagate	./src/geom/projectiles.jl	/^propagate(P::Projectile, Δt::Float64) = Projectile(P.pos + polar(P.v*Δt, P.pos.θ), P.v)$/;"	f
radius_of_curvature_in_the_meridian	./src/coordinate_transforms.jl	/^function radius_of_curvature_in_the_meridian(ϕ::Float64, datum::GeodeticDatum)$/;"	f
radius_of_curvature_in_the_prime_vertical	./src/coordinate_transforms.jl	/^function radius_of_curvature_in_the_prime_vertical(ϕ::Float64, datum::GeodeticDatum=WGS_84)$/;"	f
rot	./src/geom/lines.jl	/^rot(line::Line, Δθ::Float64) = Line(line.C, line.θ+Δθ)$/;"	f
rot	./src/vecE2.jl	/^function rot(a::VecE2, θ::Float64)$/;"	f
rot	./src/vecE3.jl	/^function rot(a::VecE3, axis::VecE3, θ::Real)$/;"	f
rot	./src/vecSE2.jl	/^rot(a::VecSE2, Δθ::Float64) = VecSE2(a.x, a.y, a.θ+Δθ)$/;"	f
rot_normalized	./src/vecE3.jl	/^function rot_normalized(a::VecE3, axis::VecE3, θ::Real)$/;"	f
